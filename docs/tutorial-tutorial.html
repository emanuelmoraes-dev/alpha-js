<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Tutorial: Alpha Restful (Versão Beta) | Alpha Restful</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/tui-doc.css">

    
</head>
<body>
<nav class="lnb" id="lnb">
    <div class="logo" style="">
        
            <img src="img/toast-ui.png" width="100%" height="100%">
        
    </div>
    <div class="title">
        <h1><a href="index.html" class="link">Alpha Restful</a></h1>
        
    </div>
    <div class="search-container" id="search-container">
        <input type="text" placeholder="Search">
        <ul></ul>
    </div>
    
        <ol class="lnb-tab">
            <li id="api-tab">
                <a href="#"><h4>API</h4></a>
            </li>
            <li id="examples-tab">
                <a href="#"><h4>Tutorials</h4></a>
            </li>
        </ol>
    
    <div class="lnb-examples hidden"><h3>Tutorials</h3><ul><li><a href="tutorial-tutorial.html">Alpha Restful (Versão Beta)</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="tutorial_sub"></div></li></ul></div><div class="lnb-api hidden"><h3>Global</h3><ul><li><a href="global.html#normalizePort">normalizePort</a></li><li><a href="global.html#onError">onError</a></li><li><a href="global.html#onListening">onListening</a></li></ul></div>
</nav>
<div id="resizer"></div>

<div class="main" id="main">
    

<section>
    <header>
        

        <h2>Alpha Restful (Versão Beta)</h2>
    </header>

    
        <article class="readme">
            <p>O Alpha Restful é um framework para o desenvolvimento de aplicações web Rest backend em MongoDB, feito para Node JS. Esta ferramenta é executada em cima do Express JS e da ORM de banco de dados Mongoose.</p>
<h2>Atenção!</h2>
<p>O Alpha Restful possui compatibilidade <strong>apenas</strong> com o <strong>NODE 8 ou superior!</strong></p>
<p>O Alpha Restful está em versão Beta. Por causa disto, eventualmente algum erro poderá ocorrer. Caso você detecte algum erro, sinta-se livre para fazer uma publicação nas Issues do github, que eu tentarei resolver o mais rápido possível.</p>
<h2>Mas Porque Usar o Alpha Restful?</h2>
<ul>
<li>
<p>O Alpha Restful gerencia todas as suas entidades e sub-entidades.</p>
<ul>
<li>
<p>Todas as entidades com seus respectivos relacionamentos entre si são gerenciadas e integradas com várias funções disponibilizadas pelo framework.</p>
</li>
<li>
<p>Ao declarar uma entidade, é possível definir várias opções em seus atributos e relacionamentos.</p>
<ul>
<li>
<p>Com apenas a habilitação de uma opção, os atributos relacionados com outra entidade são preenchidos por todos os atributos armazenados na entidade relacionada, mesmo estando em outro documento.</p>
</li>
<li>
<p>Com apenas a habilitação de uma opção, uma instância de uma entidade não pode ser removida se possuir um relacionamento com um atributo de outra entidade.</p>
</li>
<li>
<p>Com apenas a habilitação de uma opção, as instâncias relacionadas com a instância da qual deseja-se remover, serão removidas também.</p>
</li>
</ul>
</li>
<li>
<p>Ao remover a instância de uma entidade, automaticamente são removidos seus valores nas instâncias de entidades relacionadas (É possível desativar esta função caso desejado).</p>
</li>
<li>
<p>É possível definir atributos de relacionamento entre duas entidades. Estes atributos de relacionamento podem inclusive ter relacionamento com outra entidade e ainda podem possuir outros atributos que por sua vez também podem ter relacionamento com outras entidades, podendo repetir este procedimento em qualquer quantidade de níveis.</p>
</li>
<li>
<p>Com o Alpha Restful você poderá realizar relacionamento virtual entre entidades, evitando a criação de rotas e códigos de pesquisa personalizados desnecessários.</p>
</li>
<li>
<p>É disponibilizado um método de busca, na qual pode-se fazer uma pesquisa por atributos de sub-entidades de qualquer nível, como se estas sub-entidades e sub-entidades de sub-entidades estivessem dentro do mesmo objeto, mesmo estando armazenadas em documentos separados.</p>
</li>
</ul>
</li>
<li>
<p>O Alpha Restful é rápido e fácil!</p>
<ul>
<li>
<p>O desenvolvimento de uma API Rest backend se torna extremamente fácil e simples de ser desenvolvido! Com pouquíssimas linhas de código um aplicação completa pode ser criada!</p>
</li>
<li>
<p>As funções e verificações, além das disponibilizadas pelo MongoDB e Mongoose, possui um ótimo desempenho, mas podem ser desativadas individualmente para garantir uma performance ou liberdade ainda maior.</p>
</li>
<li>
<p>O Alpha Restful gera todas as rotas CRUD padrão de uma aplicação Rest, bastando apenas definir quais métodos http você deseja que seja criado.</p>
</li>
<li>
<p>Com apenas a passagem de uma simples opção no modelo da entidade, é gerado uma rota padrão &quot;get&quot; de busca da entidade. Nesta rota de busca, é possível realizar pesquisas filtradas complexas, de maneira bastante simples e utilizando atributos da entidade e das sub-entidades relacionadas sem a necessidade de criar nada além do modelo da entidade.</p>
</li>
</ul>
</li>
<li>
<p>Liberdade! Flexibilidade! e Adaptabilidade!</p>
<ul>
<li>
<p>Cada funcionalidade disponibilizada por esta ferramenta foi organizada e modularizada. Isto significa que o programador poderá facilmente modificar e sobrescrever cada ação realizada pelo framework, sem a modificação de seu código fonte aqui presente!</p>
</li>
<li>
<p>Cada função desta ferramenta possui a opção de ser desabilitada caso o programador deseje uma performance ou liberdade ainda maior.</p>
</li>
<li>
<p>Cada funcionalidade poderá ser utilizada em separado em procedimentos e rotas personalizadas do programador. Isto implica que as funções aqui apresentadas poderão ser utilizadas de diferentes maneiras, dependendo apenas da maneira como elas são chamadas/definidas.</p>
</li>
<li>
<p>O Alpha Restful é altamente adaptável, ou seja, caso você já possua uma aplicação backend, usando node js, express js e Mongoose, torna-se muito fácil integrar este framework ou parte dele em seu código já existente!</p>
</li>
<li>
<p>Com o Alpha Restful o programador terá a total liberdade de alterar qualquer comportamento genérico ou específico da ferramenta, adaptando seu comportamento para as suas necessidades.</p>
</li>
</ul>
</li>
<li>
<p>O Alpha Restful é Livre! e completamente Gratuito! Sinta-se a vontade para utilizar esta ferramenta para qualquer fim comercial ou não comercial.</p>
</li>
</ul>
<h2>Guia</h2>
<p>Aqui será apresentado um guia para você poder já sair programando!</p>
<h3>Atenção</h3>
<p>Este guia <strong>não</strong> engloba todas as funções implementadas pelo Alpha Restful. Em breve será disponibilizado uma documentação completa com todas as funções e opções que podem ser utilizadas!</p>
<h3>Instalação</h3>
<h4>Preparando Ambiente</h4>
<ul>
<li>
<p>Instale o Node JS em seu computador clicando <a href="https://nodejs.org/en/download/">neste link</a>.</p>
</li>
<li>
<p>Instale o banco de dados MongoDB em seu computador clicando <a href="https://www.mongodb.com/download-center/community">neste link</a>.</p>
</li>
</ul>
<h4>Criando Aplicação Node</h4>
<p>Você pode criar uma nova aplicação Node através do seguinte comando:</p>
<pre class="prettyprint source lang-sh"><code>npm init -y
</code></pre>
<h4>Incluindo o Alpha Restful em seu Projeto</h4>
<p>Execute o seguinte código no diretório de seu projeto</p>
<pre class="prettyprint source lang-sh"><code>npm install alpha-restful --save
</code></pre>
<h3>Preparando o Ambiente Express JS</h3>
<p>O Alpha Restful executa em cima do Express JS. Para mais informações sobre o Express JS, acesse o link <a href="https:%5C/%5C/expressjs.com/">https://expressjs.com/</a>.</p>
<p>Se você já trabalha com o Express JS você poderá pular esta seção.</p>
<p>A seguir será exibido um exemplo de código que prepara o ambiente do Express JS, que poderá ser colocado no arquivo principal (primeiro script a ser executado) de sua aplicação:</p>
<pre class="prettyprint source lang-js"><code>const express = require('express')
const path = require('path')
const cookieParser = require('cookie-parser')
const logger = require('morgan')

const app = express()

app.use(logger('dev'))
app.use(express.json())
app.use(express.urlencoded({ extended: false }))
app.use(cookieParser())
app.use(express.static(path.join(__dirname, 'public')))
</code></pre>
<h3>Inicializando o seu Servidor</h3>
<p>Para inicializar sua aplicação na porta <em>3001</em>, com o banco de dados no <em>localhost</em> com o nome do banco <em>db_test</em> e com o nome da aplicação de <em>aplicacao-teste</em>, basta acrescentar no final de seu script principal o seguinte código:</p>
<pre class="prettyprint source lang-js"><code>const mongoose = require('mongoose') // ORM de banco de dados MongoDB
const { Connector, www, Restful, Entity } = require('alpha-restful') // Importa módulos do Alpha-Restful
const restful = new Restful('aplicacao-teste', {
  locale: 'en'
}) // Instância do Alpha Restful

// ...

process.env.PORT = 3001 // Porta do servidor
const connector = new Connector('mongodb://localhost/db_test', restful, app) // Conexão com Banco de Dados Mongo DB
www(connector, true) // Inicializia o servidor
</code></pre>
<p>O primeiro argumento do construtor de <code>Restful</code> é o nome da sua aplicação. Neste caso definiu-se o nome da aplicação de <em>aplicacao-teste</em>.</p>
<p>O segundo argumento deste construtor é um objeto opcional que contém várias opções. Em breve será disponibilizado uma explicação detalhada para cada opção. Umas dessas opções é a opção <code>locale</code>, que representa a linguagem na qual o banco de dados <em>mongodb</em> irá reconhecer. Este <em>locale</em> é utilizado para a chamada automática da função <em>collation</em> do <em>mongodb</em> para, por exemplo, possibilitar uma ordenação ignorando acentos e letras maiúsculas/minúsculas. Dependendo de sua versão do <em>mongodb</em>, um erro poderá ocorrer neste <code>collation</code>. Para corrigir este erro (caso ocorra), basta remover o uso do <code>collation</code> com a opção <code>isLocale</code> igual a <code>false</code>.</p>
<p>Caso o locale não seja definido, o padrão é o inglês (<em>en</em>). A seguir é apresentado uma tabela com todas as linguagens suportadas pelo <em>locale</em>.</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Locale</th>
</tr>
</thead>
<tbody>
<tr>
<td>Afrikaans</td>
<td>af</td>
</tr>
<tr>
<td>Albanian</td>
<td>sq</td>
</tr>
<tr>
<td>Amharic</td>
<td>am</td>
</tr>
<tr>
<td>Armenian</td>
<td>hy</td>
</tr>
<tr>
<td>Arabic</td>
<td>ar</td>
</tr>
<tr>
<td>Assamese</td>
<td>as</td>
</tr>
<tr>
<td>Azeri</td>
<td>az</td>
</tr>
<tr>
<td>Bengali</td>
<td>bn</td>
</tr>
<tr>
<td>Belarusian</td>
<td>be</td>
</tr>
<tr>
<td>Bengali</td>
<td>bn</td>
</tr>
<tr>
<td>Bosnian</td>
<td>bs</td>
</tr>
<tr>
<td>Bosnian (Cyrillic)</td>
<td>bs_Cyrl</td>
</tr>
<tr>
<td>Bulgarian</td>
<td>bg</td>
</tr>
<tr>
<td>Burmese</td>
<td>my</td>
</tr>
<tr>
<td>Catalan</td>
<td>ca</td>
</tr>
<tr>
<td>Cherokee</td>
<td>chr</td>
</tr>
<tr>
<td>Chinese</td>
<td>zh</td>
</tr>
<tr>
<td>Chinese (Traditional)</td>
<td>zh_Hant</td>
</tr>
<tr>
<td>Croatian</td>
<td>hr</td>
</tr>
<tr>
<td>Czech</td>
<td>cs</td>
</tr>
<tr>
<td>Danish</td>
<td>da</td>
</tr>
<tr>
<td>Dutch	nl</td>
<td>nl</td>
</tr>
<tr>
<td>Dzongkha</td>
<td>dz</td>
</tr>
<tr>
<td>English</td>
<td>en</td>
</tr>
<tr>
<td>English (United States)</td>
<td>en_US</td>
</tr>
<tr>
<td>English (United States, Computer)</td>
<td>en_US_POSIX</td>
</tr>
<tr>
<td>Esperanto</td>
<td>eo</td>
</tr>
<tr>
<td>Estonian</td>
<td>et</td>
</tr>
<tr>
<td>Ewe</td>
<td>ee</td>
</tr>
<tr>
<td>Faroese</td>
<td>fo</td>
</tr>
<tr>
<td>Filipino</td>
<td>fil</td>
</tr>
<tr>
<td>Finnish</td>
<td>fi_FI</td>
</tr>
<tr>
<td>French</td>
<td>fr</td>
</tr>
<tr>
<td>French (Canada)</td>
<td>fr_Ca</td>
</tr>
<tr>
<td>Galician</td>
<td>gl</td>
</tr>
<tr>
<td>Georgian</td>
<td>ka</td>
</tr>
<tr>
<td>German</td>
<td>de</td>
</tr>
<tr>
<td>German (Austria)</td>
<td>de_AT</td>
</tr>
<tr>
<td>Greek</td>
<td>rl</td>
</tr>
<tr>
<td>Gujarati</td>
<td>gu</td>
</tr>
<tr>
<td>Hausa</td>
<td>ha</td>
</tr>
<tr>
<td>Hawaiian</td>
<td>haw</td>
</tr>
<tr>
<td>Hebrew</td>
<td>he</td>
</tr>
<tr>
<td>Hindi</td>
<td>hi</td>
</tr>
<tr>
<td>Hungarian</td>
<td>hu</td>
</tr>
<tr>
<td>Icelandic</td>
<td>is</td>
</tr>
<tr>
<td>Igbo</td>
<td>ig</td>
</tr>
<tr>
<td>Inari Sami</td>
<td>smn</td>
</tr>
<tr>
<td>Indonesian</td>
<td>id</td>
</tr>
<tr>
<td>Irish</td>
<td>gs</td>
</tr>
<tr>
<td>Italian</td>
<td>it</td>
</tr>
<tr>
<td>Japanese</td>
<td>ja</td>
</tr>
<tr>
<td>Kalaallisut</td>
<td>kl</td>
</tr>
<tr>
<td>Kannada</td>
<td>kn</td>
</tr>
<tr>
<td>Kazakh</td>
<td>kk</td>
</tr>
<tr>
<td>Khmer</td>
<td>km</td>
</tr>
<tr>
<td>Konkani</td>
<td>kok</td>
</tr>
<tr>
<td>Korean</td>
<td>ko</td>
</tr>
<tr>
<td>Kyrgyz</td>
<td>ky</td>
</tr>
<tr>
<td>Lakota</td>
<td>lk</td>
</tr>
<tr>
<td>Lao</td>
<td>lo</td>
</tr>
<tr>
<td>Latvian</td>
<td>lv</td>
</tr>
<tr>
<td>Lingala</td>
<td>li</td>
</tr>
<tr>
<td>Lithuanian</td>
<td>lt</td>
</tr>
<tr>
<td>Lower Sorbian</td>
<td>dsb</td>
</tr>
<tr>
<td>Luxembourgish</td>
<td>lb</td>
</tr>
<tr>
<td>Macedonian</td>
<td>mk</td>
</tr>
<tr>
<td>Malay</td>
<td>ms</td>
</tr>
<tr>
<td>Malayalam</td>
<td>ml</td>
</tr>
<tr>
<td>Maltese</td>
<td>mt</td>
</tr>
<tr>
<td>Marathi</td>
<td>mr</td>
</tr>
<tr>
<td>Mongolian</td>
<td>mn</td>
</tr>
<tr>
<td>Nepali</td>
<td>ne</td>
</tr>
<tr>
<td>Northern Sami</td>
<td>se</td>
</tr>
<tr>
<td>Norwegian Bokmål</td>
<td>nb</td>
</tr>
<tr>
<td>Norwegian Nynorsk</td>
<td>nn</td>
</tr>
<tr>
<td>Oriya</td>
<td>or</td>
</tr>
<tr>
<td>Oromo</td>
<td>om</td>
</tr>
<tr>
<td>Pashto</td>
<td>ps</td>
</tr>
<tr>
<td>Persian</td>
<td>fa</td>
</tr>
<tr>
<td>Persian (Afghanistan)</td>
<td>fa_AF</td>
</tr>
<tr>
<td>Polish</td>
<td>pl</td>
</tr>
<tr>
<td>Portuguese</td>
<td>pt</td>
</tr>
<tr>
<td>Punjabi</td>
<td>pa</td>
</tr>
<tr>
<td>Romanian</td>
<td>ro</td>
</tr>
<tr>
<td>Russian</td>
<td>ru</td>
</tr>
<tr>
<td>Serbian</td>
<td>sr</td>
</tr>
<tr>
<td>Serbian (Latin)</td>
<td>sr_Latn</td>
</tr>
<tr>
<td>Sinhala</td>
<td>si</td>
</tr>
<tr>
<td>Slovak</td>
<td>sk</td>
</tr>
<tr>
<td>Slovenian</td>
<td>sl</td>
</tr>
<tr>
<td>Spanish</td>
<td>es</td>
</tr>
<tr>
<td>Swahili</td>
<td>sw</td>
</tr>
<tr>
<td>Swedish</td>
<td>sv</td>
</tr>
<tr>
<td>Tamil</td>
<td>ta</td>
</tr>
<tr>
<td>Telugu</td>
<td>te</td>
</tr>
<tr>
<td>Thai</td>
<td>th</td>
</tr>
<tr>
<td>Tibetan</td>
<td>bo</td>
</tr>
<tr>
<td>Tongan</td>
<td>to</td>
</tr>
<tr>
<td>Turkish</td>
<td>tr</td>
</tr>
<tr>
<td>Ukrainian</td>
<td>uk</td>
</tr>
<tr>
<td>Upper Sorbian</td>
<td>hsb</td>
</tr>
<tr>
<td>Urdu</td>
<td>ur</td>
</tr>
<tr>
<td>Uyghur</td>
<td>ug</td>
</tr>
<tr>
<td>Vietnamese</td>
<td>vi</td>
</tr>
<tr>
<td>Walser</td>
<td>wae</td>
</tr>
<tr>
<td>Welsh</td>
<td>cy</td>
</tr>
<tr>
<td>Yiddish</td>
<td>yi</td>
</tr>
<tr>
<td>Yoruba</td>
<td>yo</td>
</tr>
<tr>
<td>Zulu</td>
<td>zu</td>
</tr>
</tbody>
</table>
<p>O primeiro argumento do construtor da classe <code>Connector</code> é a URL do local onde o banco de dados mongodb está localizado. O segundo argumento é a instância da classe <code>Restful</code>, que representa a instância do framework <em>Alpha Restful</em>. O terceiro argumento é a instância do Express JS.</p>
<p>O primeiro argumento da função <code>www</code> é o connector do banco de dados MongoDB. Se o segundo argumento for <code>true</code>, o Alpha Restful irá gerar automaticamente rotas para tratamento de erros. O <code>www</code> é uma função que retorna uma promise, na qual o retorno da promise é um objeto contendo o atributo <code>server</code> (representando a chamada do método <code>require('http').createServer(app)</code>) e o atributo <code>debug</code> (usado para mostrar mensagens de debug).</p>
<p>Toda a implementação de sua aplicação deverá ocorrer antes da chamada do método <code>www</code>. Aqui serão mostrados códigos como se estivessem dentro de um mesmo arquivo, mas o programador poderá se sentir a vontade de modularizar seu código em vários arquivos seguindo a estrutura que achar melhor.</p>
<p>Para executar a sua aplicação, basta executar o comando:</p>
<pre class="prettyprint source lang-sh"><code>node &lt;arquivo-principal>.js
</code></pre>
<p>Para executar a sua aplicação no <em>linux</em> / <em>Mac OS</em> no modo <em>debug</em> execute:</p>
<pre class="prettyprint source lang-sh"><code>DEBUG=&lt;nome-da-aplicação>:* node &lt;arquivo-principal>.js
</code></pre>
<p>Para executar a sua aplicação no <em>windows</em> no modo <em>debug</em> execute:</p>
<pre class="prettyprint source lang-sh"><code>set DEBUG=&lt;nome-da-aplicação>:* & node &lt;arquivo-principal>.js
</code></pre>
<h3>Modelando suas Entidades</h3>
<p>Digamos que você deseje criar a entidade <em>Pessoa</em> com o atributo <em>nome</em> e <em>idade</em>, disponível na URI <em>/pessoas</em>. Para fazer isto bastaria fazer o seguinte código:</p>
<pre class="prettyprint source lang-js"><code>const Pessoa = new Entity({
    name: 'Pessoa', // Nome da sua entidade
    resource: '/pessoas', // URI utilizada para acessar os recursos REST desta entidade. Também é o nome da coleção de documentos utilizada para esta entidade (sem a barra)
    descriptor: { // Objeto que descreve os atributos da entidade
        name: String, // Uma pessoa possui um nome que é do tipo String
        idade: Number // Uma pessoa possui uma idade que é do tipo Number
    }
})

restful.add(Pessoa) // Adiciona ao Restful a entidade Pessoa
</code></pre>
<p>O <em>descriptor</em> descreve como a entidade <em>Pessoa</em> está modelada. A sintaxe do descriptor segue as especificações presentes nos <a href="https://mongoosejs.com/docs/guide.html"><em>schemas</em></a> do Mongoose.</p>
<h3>Integração com o Mongoose</h3>
<p>O Alpha Restful é completamente integrado com o Mongoose. Todas as funcionalidade disponibilizadas pelo Mongoose poderão ser utilizadas dentro de seu projeto Alpha Restful.</p>
<p>Para acessar o <a href="https://mongoosejs.com/docs/guide.html">schema</a> da entidade para uso do Mongoose, basta digitar <code>Pessoa.schema</code>. Para acessar o <a href="https://mongoosejs.com/docs/models.html">model</a> da entidade para uso do Mongoose, basta digitar <code>Pessoa.model</code>.</p>
<h3>Criando CRUD de Entidade</h3>
<p>Para que o Alpha Restful crie as rotas dos métodos http de CRUD, basta informar na entidade quais métodos http devem ser gerados automaticamente:</p>
<pre class="prettyprint source lang-js"><code>const Pessoa = new Entity({
    name: 'Pessoa', // Nome da sua entidade
    resource: '/pessoas', // URI utilizada para acessar os recursos REST desta entidade. Também é o nome da coleção de documentos utilizada para esta entidade (sem a barra)
    descriptor: { // Objeto que descreve os atributos da entidade
        name: String, // Uma pessoa possui um nome que é do tipo String
        idade: Number // Uma pessoa possui uma idade que é do tipo Number
    },
    methods: ['get', 'post', 'put', 'delete', 'patch'] // Métodos http dos CRUDS
})
</code></pre>
<p>Para que o Alpha Restful gere automaticamente todas as rotas de CRUD definidas em todas as entidade, é necessário executar o seguinte código <strong>após</strong> a definição das entidades:</p>
<pre class="prettyprint source lang-js"><code>restful.applyRouters(app)
</code></pre>
<h3>Relacionamento entre Entidades</h3>
<p>O Mongoose possui uma funcionalidade chamada de <a href="https://mongoosejs.com/docs/populate.html">populate</a>. Esta funcionalidade permite um certo relacionamento entre entidades.</p>
<p>Porém o Alpha Restful disponibiliza seu próprio método de relacionamento entre entidades, disponibilizando diversas funções a mais.</p>
<p>Para que as funcionalidades a seguir descritas funcionem, é necessário que o relacionamento entre entidades seja realizado por meio do Alpha Restful.</p>
<h4>Relacionamento no Dono da Relação (Onde Serão Armazenados os ids)</h4>
<p>Digamos que você crie uma entidade chamada de <em>Casa</em>, e deseje fazer um relacionamento de muitos para muitos entre <em>Casa</em> e <em>Pessoa</em>. Neste caso, bastaria implementar o modelo da entidade <em>Casa</em> e definir o relacionamento em algum atributo da entidade:</p>
<pre class="prettyprint source lang-js"><code>const Casa = new Entity({
    name: 'Casa',
    resource: 'casas',
    descriptor: {
        endereco: {
            numero: String,
            rua: String,
            cidade: String,
            estado: String,
            pais: String
        },
        /*
        Uma casa possui várias pessoas. No documento da
        entidade Casa, armazena-se uma lista de objetos,
        na qual pelo menos o id da entidade Pessoa deve
        ser armazenada
        */
        pessoas: [{
            id: mongoose.Schema.Types.ObjectId // Id da entidade pessoa
        }]
    },
    /*
    A opção sync é responsável por descrever o comportamento
    de cada atributo da entidade. Nesta opção, torna-se
    possível sincronizar um atributo da entidade com
    instâncias de outras entidades
    */
    sync: {
        pessoas: 'Pessoa'
    },
    methods: ['get', 'post', 'put', 'delete', 'patch']
})
</code></pre>
<p>Na entidade <em>Casa</em>, definiu-se o atributo <em>pessoas</em>. Neste atributo será armazenado uma lista de objetos contendo atributos de cada pessoa relacionada. O <em>id</em> deve ser obrigatoriamente armazenado, mas outros atributos da entidade podem ser armazenados, assim como atributos presentes no relacionamento entre <em>Casa</em> e <em>Pessoa</em>. Caso a entidade <em>Casa</em> possua apenas uma pessoa, bastaria remover os colchetes ( [ ] ) que envolvem a definição do objeto armazenado pelo atributo.</p>
<p>Através da opção <em>sync</em>, sincronizou-se o atributo <em>pessoas</em> com a entidade <em>Pessoa</em>. Através do <em>sync</em>, diversas opções estão disponíveis para o atributo sincronizado. Neste exemplo, apenas um relacionamento simples está definido. Para relacionamentos simples (relacionamentos sem outras opções), basta colocar no lado direito uma String contendo o nome da entidade relacionada.</p>
<h4>Relacionamento na Entidade Relacionada</h4>
<p>Mas, e se desejarmos obter na entidade <em>Pessoa</em> a lista de casas relacionadas a ela? Nós não podemos repetir o procedimento anterior na entidade <em>Pessoa</em>, pois o Alpha Restful interpretaria isso como outro relacionamento. Nós poderíamos criar um novo atributo em <em>Pessoa</em> para armazenar manualmente todos os ids das casas que se relacionam com a pessoa armazenada, porém isto deixaria o código da sua aplicação complexa e suscetível a erros humanos.</p>
<p>Pensando nisto, o Alpha Restful dispõe de uma opção na qual você informa que existe um atributo virtual, representando o relacionamento feito por outra entidade. Este atributo não é armazenado em seu banco de dados, porém o Alpha Restful irá considerar este atributo como se ele estivesse declarado na entidade. Tal atributo virtual representa o relacionamento na entidade relacionada, sem que seja necessário adicionar nenhum dado no documento do MongoDB.</p>
<p>Para realizar este procedimento, a fim de obter em pessoa as casas a ela relacionada, bastaria adicionar no <em>sync</em> um atributo com a opção <em>syncronized</em>:</p>
<pre class="prettyprint source lang-js"><code>const Pessoa = new Entity({
    name: 'Pessoa',
    resource: '/pessoas',
    descriptor: {
        name: String,
        idade: Number
    },
    sync: {
        /*
        Como este relacionamento exige a passagem de
        novas opções, ao invés da String contendo o
        nome da entidade, coloca-se um objeto, na
        qual o atributo name é o nome da entidade
        relacionada.
        */
        casas: {
            name: 'Casa',

            /*
            A opção syncronized descreve
            o nome do atributo que realiza o
            relacionamento com esta entidade.
            */
            syncronized: ['pessoas']
        }
    },
    methods: ['get', 'post', 'put', 'delete', 'patch']
})
</code></pre>
<p>No <em>sync</em> da entidade <em>Pessoa</em>, defini-se que uma pessoa possui um relacionamento com <em>Casa</em>, porém o atributo <em>casas</em> não será armazenado no banco (por isso este atributo não está presente no <em>descriptor</em>), porém o Alpha Restful irá considerar a existência de tal atributo em pesquisas no banco de dados. A opção <em>syncronized</em> no <em>sync</em> de <em>Pessoa</em> contém o nome do atributo na entidade <em>Casa</em> que se relaciona com <em>Pessoa</em>. Se houverem várias casas, envolve-se em colchetes ( [ ] ) o nome do atributo. Caso haja sempre apenas uma <em>Casa</em>, remove-se os colchetes no nome do atributo em <em>syncronized</em>.</p>
<p>Por padrão o Alpha Restful irá buscar todos os ids das casas relacionadas com esta pessoa e colocar no atributo <em>casas</em> automaticamente em tempo de execução. Para que este atributo não seja buscado ao realizar uma busca por pessoa, basta adicionar uma opção de <em>jsonIgnore</em> que será explicado mais a frente. Mesmo que seja adicionada esta opção, você ainda poderá buscar pessoas filtradas por este atributo.</p>
<h4>Garantia Automática de Consistência dos Dados</h4>
<p>Neste exemplo na qual estamos abordando, caso uma pessoa seja removida, automaticamente serão removidos os atributos da pessoa nas instâncias de entidades que se relacionam com <em>Pessoa</em>. Desta forma não haverá ids de entidades que já não existem mais no banco de dados. Se por algum motivo você desejar que este comportamento seja desativado em algum atributo, basta adicionar a opção <em>ignoreVerifyRelationship</em> com o valor <code>true</code> no <em>sync</em> do atributo da entidade desejada.</p>
<h3>Atributos de Relacionamento</h3>
<p>O Alpha Restful permite que sejam definidos atributos de relacionamentos. Estes atributos de relacionamento podem ser atributos presentes dentro da entidade relacionada, como também podem ser atributos presentes apenas dentro do relacionamento.</p>
<p>Como exemplo, imagine a seguinte situação: imagine que no relacionamento entre <em>Pessoa</em> e <em>Casa</em> existe um aluguel. Vamos imaginar que por algum motivo o aluguel precisa ser modelado como uma entidade separada. Neste caso, pode-se representar esta situação com o seguinte código:</p>
<pre class="prettyprint source lang-js"><code>const Aluguel = new Entity({
    name: 'Aluguel',
    resource: 'alugueis',
    descriptor: {
        valor: Number,
        dataInicio: Date,
        dataFim: Date
    },
    methods: ['get', 'post', 'put', 'delete', 'patch']
})

restful.add(Aluguel)

const Casa = new Entity({
    name: 'Casa',
    resource: 'casas',
    descriptor: {
        endereco: {
            numero: String,
            rua: String,
            cidade: String,
            estado: String,
            pais: String
        },
        pessoas: [{
            id: mongoose.Schema.Types.ObjectId,

            /*
            No relacionamento entre Pessoa e Casa existe
            um atributo de relacionamento chamado aluguel
            que por sua vez se relaciona com a entidade
            Aluguel
            */
            aluguel: {
                id: mongoose.Schema.Types.ObjectId
            }
        }]
    },
    sync: {
        pessoas: {
            name: 'Pessoa',

            /*
            Dentro de cada pessoa existe um atributo de
            relacionamento chamado aluguel que se
            relaciona com a entidade Aluguel
            */
            sync: {
                aluguel: 'Aluguel'
            }
        }
    },
    methods: ['get', 'post', 'put', 'delete', 'patch']
})
</code></pre>
<p>Atributos de relacionamento são atributos normais, na qual podem se relacionar com outras entidades e podem receber opções como qualquer outra opção.</p>
<h3>Json Ignore</h3>
<p>Caso você deseje que determinado atributo não seja adicionado por padrão no json de busca da entidade, basta colocar a opção <em>jsonIgnore</em> no <em>sync</em> do atributo na qual deseja-se que seja omitido.</p>
<pre class="prettyprint source lang-js"><code>const Pessoa = new Entity({
    name: 'Pessoa',
    resource: '/pessoas',
    descriptor: {
        name: String,
        idade: Number
    },
    sync: {
        idade: {

            /*
            Ao buscar uma pessoa, o atributo idade não
            existirá
            */
            jsonIgnore: true
        }
        casas: {
            name: 'Casa',
            syncronized: ['pessoas'],

            /*
            Ao buscar uma pessoa, o atributo casas não
            existirá
            */
            jsonIgnore: true
        }
    },
    methods: ['get', 'post', 'put', 'delete', 'patch']
})
</code></pre>
<p>Neste exemplo, os atributos <em>idade</em> e <em>casas</em> não serão incluídos no json de busca da entidade <em>Pessoa</em>.</p>
<h4>Atenção!!</h4>
<p>Por questões de desempenho, somente atributos diretos são garantidos de maneira incondicional a serem ignorados pelo <em>jsonIgnore</em>, ou seja, na entidade <em>Casa</em>, os atributos dentro de <em>endereco</em> não serão ignorados de maneira individual. Os atributos dentro de <em>endereco</em> serão ignorados se o atributo <em>endereco</em> for ignorado. Caso você deseje que um sub-atributo possa ser ignorado de maneira garantida e individual, basta adicionar a opção <em>ignoreFieldsRecursive</em> como <code>false</code> nas opções da entidade.</p>
<p>O <em>jsonIgnore</em> é aplicado na função de preenchimento de entidades explicada posteriormente.</p>
<h3>Rotas Personalizadas com Funções Assincronas</h3>
<p>Se você deseja criar uma rota personalizada usando funções assincronas, você pode utilizar o método <code>restful.execAsync</code>.</p>
<p>Como exemplo, vamos criar a estrutura de uma rota http <em>get</em> com a URI <em>/rota-personalizada</em>:</p>
<pre class="prettyprint source lang-js"><code>app.get('/rota-personalizada',
    restful.execAsync(async function (req, res, next) {
        // ...
        // Executando alguma coisa
        // ...
    })
)
</code></pre>
<p>Para mais informações sobre a criação de rotas personalizadas com o Express JS acesse <a href="https:%5C/%5C/expressjs.com/en/starter/basic-routing.html">https://expressjs.com/en/starter/basic-routing.html</a>.</p>
<h4>Atenção</h4>
<p>Independente da função da rota ser assincrona ou sincrona, para passar a execução para a rota seguinte é necessário chamar o método <code>next()</code>. Se a rota retornar o resultado para o cliente, o método <code>next()</code> não deverá ser chamado. Caso ocorra algum erro, pode-se colocar o objeto do erro na chamada da função <code>next</code> da seguinte forma: <code>next(&lt;objeto do erro&gt;)</code>. Mais informações podem ser obtidas na <a href="https://expressjs.com/en/starter/basic-routing.html">documentação de roteamento do Express JS</a>.</p>
<h3>Preenchimento Automático de Entidade Relacionada</h3>
<p>Se você desejar que por padrão uma entidade relacionada tenha seus atributos buscados e colocados no atributo do relacionamento, basta adicionar a opção <em>fill</em> no <em>sync</em> do atributo da entidade desejada:</p>
<pre class="prettyprint source lang-js"><code>const Casa = new Entity({
    name: 'Casa',
    resource: 'casas',
    descriptor: {
        endereco: {
            numero: String,
            rua: String,
            cidade: String,
            estado: String,
            pais: String
        },
        pessoas: [{
            id: mongoose.Schema.Types.ObjectId,
            aluguel: { id: mongoose.Schema.Types.ObjectId }
        }]
    },
    sync: {
        pessoas: {
            name: 'Pessoa',

            /*
            Caso fill seja true, o atributo pessoas
            receberá os valores contidos na entidade
            relacionada
            */
            fill: true,

            sync: { aluguel: 'Aluguel' }
        }
    },
    methods: ['get', 'post', 'put', 'delete', 'patch']
})
</code></pre>
<p>Neste caso, ao buscar uma <em>Casa</em>, serão jogados no atributo <em>pessoas</em> todos os atributos existentes dentro de pessoa. Este procedimento é recursivo, ou seja, se <em>Pessoa</em> possuir atributos com <em>fill</em> igual a <code>true</code>, estes atributos de pessoa também serão preenchidos.</p>
<h4>Preenchimento Automático em Sub-Atributos</h4>
<p>Por questões de performance, um sub-atributo somente pode ser preenchido se o atributo pai tiver a opção <em>fill</em> ou <em>subFill</em> igual a <code>true</code>. Desta forma, se quisermos preencher (em nosso exemplo) somente o atributo <em>aluguel</em>, precisaríamos implementar algo como:</p>
<pre class="prettyprint source lang-js"><code>const Casa = new Entity({
    // ...
    sync: {
        pessoas: {
            name: 'Pessoa',

            /*
            Indica que um sub-atributo poderá ser
            preenchido
            */
            subFill: true,

            sync: {
                aluguel: {
                    name: 'Aluguel',

                    /*
                    Preenche o atributo aluguel com os
                    valores presentes na entidade Aluguel
                    */
                    fill: true
                }
            }
        }
    },
    // ...
})
</code></pre>
<p>Se além do aluguel quisermos preencher o atributo <em>pessoas</em>, bastaria adicionar a opção <em>fill</em> igual a <code>true</code>, ou substituir a opção <em>subFill</em> pelo atributo <em>fill</em> no <em>sync</em> de pessoas:</p>
<pre class="prettyprint source lang-js"><code>const Casa = new Entity({
    // ...
    sync: {
        pessoas: {
            name: 'Pessoa',

            /*
            Também indica que um sub-atributo poderá ser
            preenchido, porém também preenche o atributo
            pessoas
            */
            fill: true,

            sync: {
                aluguel: {
                    name: 'Aluguel',

                    /*
                    Preenche o atributo aluguel com os
                    valores presentes na entidade Aluguel
                    */
                    fill: true
                }
            }
        }
    },
    // ...
})
</code></pre>
<p>Se a opção <em>fill</em> é igual a <code>true</code>, o atributo sincronizado irá ser preenchido, mas se além desta opção também está presente a opção <em>subFill</em> igual a <code>false</code>, então o Alpha Restful não irá preencher os sub-atributos dos níveis abaixo.</p>
<p>Uma alternativa ao <em>fill</em> é a opção <em>fillRec</em>. Tal opção contém um número que indica quantos níveis abaixo serão preenchidos com a opção <em>fill</em> igual a <code>true</code>. Se <em>fillRec</em> for um número negativo, o Alpha Restful irá tentar expandir todos os níveis abaixo em todos os sub-atributos da entidade e das sub-entidades. A opção <em>fill</em> possui maior prioridade que a opção <em>fillRec</em>. Se <em>fillRec</em> for negativo, a recursão somente terminará se algum <em>fill</em> abaixo for igual a <code>false</code> ou se não houver mais atributos abaixo para ser preenchidos.</p>
<h5>Observação</h5>
<p>Da mesma forma, por padrão, sub-atributos somente poderão ser ignorados pelo <em>jsonIgnore</em> se o atributo pai tiver a opção <em>fill</em> ou <em>subFill</em>. Caso você deseje que sub-atributos possam ser ignorados pelo <em>jsonIgnore</em>, independente das opções <em>fill</em> e <em>subFill</em>, basta adicionar a opção <em>ignoreFieldsRecursive</em> como <code>false</code> nas opções da entidade.</p>
<p>Se você desejar que por padrão sub-atributos de sub-entidades também possam ser ignorados pelo <em>jsonIgnore</em> de maneira individual, independente das opções <em>fill</em> e <em>subFill</em>, além de adicionar a opção <em>ignoreFieldsRecursive</em> como <code>false</code>, torna-se necessário também adicionar a opção <em>ignoreFieldsRecursiveSubEntity</em> como <code>false</code> nas opções da entidade.</p>
<h4>Evitando Preenchimento Circular</h4>
<p>Digamos que desejemos preencher o atributo <em>casas</em> na entidade <em>Pessoa</em>. Para fazer isto poderíamos escrever:</p>
<pre class="prettyprint source lang-js"><code>const Pessoa = new Entity({
    name: 'Pessoa',
    resource: '/pessoas',
    descriptor: {
        name: String,
        idade: Number
    },
    sync: {
        casas: {
            name: 'Casa',
            syncronized: ['pessoas'], // Atributo usado pela Casa para se relacionar com Pessoa
            fill: true // Preenche o atributo casas com os valores da casa relacionada
        }
    },
    methods: ['get', 'post', 'put', 'delete', 'patch']
})
</code></pre>
<p>Digamos também que desejemos preencher o atributo <em>pessoas</em> na entidade <em>Casa</em>. Neste caso poderíamos também fazer o seguinte:</p>
<pre class="prettyprint source lang-js"><code>const Casa = new Entity({
    // ...
    sync: {
        pessoas: {
            name: 'Pessoa',
            fill: true, // Preenche o atributo pessoas com os valores da pessoa relacionada

            sync: {
                aluguel: { name: 'Aluguel' }
            }
        }
    },
    // ...
})
</code></pre>
<p>Se executarmos uma pesquisa por <em>Pessoa</em> ou por <em>Casa</em>, nós iremos notar um problema: o sistema irá entrar em recursão infinita, pois ao buscar uma <em>Pessoa</em>, o atributo <em>casas</em> será preenchido pelos atributos de <em>Casa</em>. Por sua vez, nos atributos de <em>Casa</em> são preenchidos os atributos de <em>Pessoa</em>, assim o procedimento segue, gerando um erro de preenchimento circular.</p>
<p>Para evitar que este erro ocorra, existem duas opções que podem ser utilizadas: <em>jsonIgnoreProperties</em> e <em>ignoreFillProperties</em>.</p>
<p>O <em>jsonIgnoreProperties</em> contém uma lista de nomes (ou apenas uma String com o nome desejado) de atributos que não serão incluídos dentro do json depois da recursão na qual esta opção está inserida.</p>
<p>O <em>ignoreFillProperties</em> contém uma lista de nomes (ou apenas uma String com o nome desejado ) de atributos que não serão preenchidos depois da recursão na qual esta opção está inserida.</p>
<pre class="prettyprint source lang-js"><code>const Pessoa = new Entity({
    // ...
    sync: {
        casas: {
            name: 'Casa',
            syncronized: ['pessoas'],
            fill: true,

            /*
            Todos os atributos abaixo desta recursão com
            o nome 'pessoas' não serão preenchidos
            */
            ignoreFillProperties: ['pessoas']
        }
    },
    // ...
})

const Casa = new Entity({
    // ...
    sync: {
        pessoas: {
            name: 'Pessoa',
            fill: true,

            /*
            Todos os atributos abaixo desta recursão com
            o nome 'casas' não serão incluídos dentro do
            json
            */
            ignoreJsonProperties: ['casas'],

            sync: {
                aluguel: { name: 'Aluguel' }
            }
        }
    },
    // ...
})
</code></pre>
<p>No código exemplo apresentado, ao buscar uma <em>Pessoa</em>, o atributo <em>pessoas</em> na entidade <em>Casa</em> não será preenchido. Ao buscar uma <em>Casa</em>, o atributo <em>casas</em> na entidade <em>Pessoa</em> não será incluído no json.</p>
<h3>Opção de Dependência em Relacionamento</h3>
<p>Digamos que uma pessoa não possa ser removida se houver um relacionamento desta pessoa com uma <em>Casa</em>. Neste caso basta informar que o relacionamento de <em>Pessoa</em> com <em>Casa</em> é um relacionamento de dependência. Para isto basta informar a opção <em>required</em> com valor <code>true</code>:</p>
<pre class="prettyprint source lang-js"><code>const Casa = new Entity({
    // ...
    sync: {
        pessoas: {
            name: 'Pessoa',
            fill: true,
            ignoreJsonProperties: ['casas'],

            /*
            As pessoas armazenadas no atributo 'pessoas'
            não poderão ser removidas enquando estiverem
            dentro deste relacionamento
            */
            required: true,

            sync: {
                aluguel: { name: 'Aluguel' }
            }
        }
    },
    // ...
})
</code></pre>
<h3>Opção de Remoção em Cascata</h3>
<p>Digamos que ao remover uma <em>Casa</em>, todas as pessoas relacionadas com esta <em>Casa</em> devam ser removida também de maneira automática. Neste caso basta colocar a opção <em>deleteCascade</em> igual a <code>true</code>.</p>
<pre class="prettyprint source lang-js"><code>const Pessoa = new Entity({
    // ...
    sync: {
        casas: {
            name: 'Casa',
            syncronized: ['pessoas'],
            fill: true,
            ignoreFillProperties: ['pessoas'],

            /*
            Se uma casa relacionada for removida, a
            pessoa relacionada será removida também
            */
            deleteCascade: true
        }
    },
    // ...
})
</code></pre>
<h3>Rota Padrão de Busca</h3>
<p>Caso seja habilitada a criação de CRUD, habilitando a geração de método http <em>get</em>, automaticamente é gerada uma rota de busca na qual buscas complexas podem ser realizadas alterando apenas os parâmetros da rota.</p>
<p>Como exemplo de busca, imagine que deseja-se buscar todas as casas, na qual existe pelo menos uma pessoa que mora em alguma <em>Casa</em>, que nesta <em>Casa</em> existe uma pessoa que possui idade maior ou igual a 18 anos. Para se realizar esta pesquisa bastaria fazer uma requisição http <em>get</em> com a seguinte url:</p>
<pre class="prettyprint source lang-http"><code>/casas?pessoas.casas.pessoas.idade__$gte=18
</code></pre>
<p>Nesta rota de busca pode-se realizar pesquisas em atributos e sub-atributos da entidade e de sub-entidades relacionadas.</p>
<p>Você também pode adicionar várias condições. Neste caso, você poderia deixar esta busca ainda mais específica, exigindo que todas as casas buscadas precisa-se estar na rua &quot;Castelo&quot;. Neste caso bastaria realizar a seguinte requisição http <em>get</em>:</p>
<pre class="prettyprint source lang-http"><code>/casas?pessoas.casas.pessoas.idade__$gte=18&endereco.rua=Castelo
</code></pre>
<p>Segue uma tabela com todas as opções de busca nesta rota de pesquisa gerada automaticamente:</p>
<table>
<thead>
<tr>
<th>Filtro</th>
<th>Condição</th>
<th>Exemplo</th>
<th>Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td>Igual</td>
<td>__$eq</td>
<td><code>/pessoas?nome=Emanuel</code> ou <code>/pessoas?nome__$eq=Emanuel</code></td>
<td>Busca todas as pessoas com o nome igual a <em>Emanuel</em></td>
</tr>
<tr>
<td>Diferente</td>
<td>__$ne</td>
<td><code>/pessoas?nome__$ne=Emanuel</code></td>
<td>Busca todas as pessoas na qual o nome é diferente de <em>Emanuel</em></td>
</tr>
<tr>
<td>Maior que</td>
<td>__$gt</td>
<td><code>/pessoas?idade__$gt=18</code></td>
<td>Busca todas as pessoas com idade maior que 18</td>
</tr>
<tr>
<td>Maior ou Igual</td>
<td>__$gte</td>
<td><code>/pessoas?idade__$gte=18</code></td>
<td>Busca todas as pessoas com idade maior ou igual a 18</td>
</tr>
<tr>
<td>Menor que</td>
<td>__$lt</td>
<td><code>/pessoas?idade__$lt=18</code></td>
<td>Busca todas as pessoas com idade menor que 18</td>
</tr>
<tr>
<td>Menor ou Igual</td>
<td>__$lte</td>
<td><code>/pessoas?idade__$lte=18</code></td>
<td>Busca todas as pessoas com idade menor ou igual a 18</td>
</tr>
<tr>
<td>Está Em</td>
<td>__$in</td>
<td><code>/pessoas?idade__$in=18,19</code></td>
<td>Busca todas as pessoas com idade igual a 18 ou 19 anos</td>
</tr>
<tr>
<td>Não Está Em</td>
<td>__$nin</td>
<td><code>/pessoas?idade__$nin=18,19</code></td>
<td>Busca todas as pessoas na qual a idade não é 18 nem 19 anos</td>
</tr>
<tr>
<td>Expressão Regular</td>
<td>__regex</td>
<td><code>/pessoas?nome__regex=/^Em/i</code></td>
<td>Busca todas as pessoas na qual o nome começa com &quot;Em&quot; (Case Insensitive)</td>
</tr>
<tr>
<td>Limite</td>
<td>limit</td>
<td><code>/pessoas?limit=10</code></td>
<td>Busca as pessoas com um limite de 10 pessoas</td>
</tr>
<tr>
<td>Pular</td>
<td>skip</td>
<td><code>/pessoas?skip=20</code></td>
<td>Busca todas as pessoas pulando as 20 primeiras pessoas da pesquisa</td>
</tr>
<tr>
<td>Ordenar Crescente</td>
<td>order</td>
<td><code>/pessoas?order=name</code></td>
<td>Busca todas as pessoas ordenando de maneira crescente por nome</td>
</tr>
<tr>
<td>Ordenar Decrescente</td>
<td>order</td>
<td><code>/pessoas?order=-name</code></td>
<td>Busca todas as pessoas ordenando de maneira decrescente por nome</td>
</tr>
<tr>
<td>Quantidade</td>
<td>selectCount</td>
<td><code>/pessoas?selectCount=true</code></td>
<td>Busca a quantidade de pessoas registradas no banco de dados</td>
</tr>
</tbody>
</table>
<h3>Método de Busca</h3>
<p>Digamos que você deseje realizar uma busca em uma rota personalizada, utilizando um poder ainda maior do que as opções disponíveis anteriormente. Neste caso, basta você chamar o método <code>restful.query(&lt;condições&gt;, &lt;Entidade&gt;, &lt;opções&gt;)</code>.</p>
<p>Por exemplo: digamos que você deseje realizar uma pesquisa de todas as casas, na qual existe pelo menos uma pessoa que mora em alguma <em>Casa</em>, que nesta <em>Casa</em> existe uma pessoa que possui idade maior ou igual a 18 anos. Para realizar esta pesquisa basta realizar a seguinte chamada de método:</p>
<pre class="prettyprint source lang-js"><code>let casas = await restful.query({
    'pessoas.casas.pessoas.idade': {
        $gte: 18
    }
}, Casa)
</code></pre>
<p>O primeiro argumento do método de busca contém as especificações do <a href="https://mongoosejs.com/docs/queries.html">objeto de busca</a> usado pelo Mongoose, com o diferencial de poder utilizar atributos de sub-entidades de sub-entidades, como se elas estivessem dentro do mesmo documento.</p>
<p>O terceiro argumento é opcional e é um objeto com várias opções para a pesquisa. As opções deste Objeto são:</p>
<table>
<thead>
<tr>
<th>Opção</th>
<th style="text-align:center">Valor Padrão</th>
<th>Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td>select</td>
<td style="text-align:center"><code>null</code></td>
<td>Atributos a serem buscados</td>
</tr>
<tr>
<td>skip</td>
<td style="text-align:center"><code>null</code></td>
<td>Quantidade de elementos a serem pulados</td>
</tr>
<tr>
<td>limit</td>
<td style="text-align:center"><code>null</code></td>
<td>Quantidade máxima de elementos  da busca</td>
</tr>
<tr>
<td>sort</td>
<td style="text-align:center"><code>null</code></td>
<td>Atributo a ser ordenado</td>
</tr>
<tr>
<td>internalSearch</td>
<td style="text-align:center"><code>true</code></td>
<td>Se for <code>false</code> retorna um objeto de busca que pode ser utilizado como primeiro argumento do método de busca do Mongoose (<code>Entidade.model.find</code>). Se for <code>true</code> retorna-se o resultado da busca</td>
</tr>
<tr>
<td>selectCount</td>
<td style="text-align:center"><code>false</code></td>
<td>Se for <code>true</code> retorna a quantidade de elementos da busca. Se for <code>false</code> retorna os elementos da busca.</td>
</tr>
<tr>
<td>isCopyEntity</td>
<td style="text-align:center"><code>false</code></td>
<td>Se for <code>false</code> <strong>não</strong> realiza a cópia das entidades buscadas. Neste caso, os atributos das entidades retornadas são imutáveis. Se for <code>true</code> as entidades retornadas são uma cópia das originais. Neste caso pode-se alterar os valores de seus atributos. As cópias das entidades <strong>não</strong> possuem os métodos utilizados pelo <em>mongoose</em>.</td>
</tr>
<tr>
<td>findOne</td>
<td style="text-align:center"><code>false</code></td>
<td>Se for <code>true</code>, apenas uma entidade é buscada e retornada.</td>
</tr>
<tr>
<td>descriptor</td>
<td style="text-align:center"><code>null</code></td>
<td>Objeto que descreve a modelagem da entidade. Caso seja <code>null</code>, o <em>descriptor</em> utilizado é o <em>descriptor</em> definido na modelagem da entidade.</td>
</tr>
</tbody>
</table>
<h4>Atenção!</h4>
<p>O método <code>restful.query</code> utiliza as definições presentes do <em>descriptor</em> das entidades para mapear as possibilizades de busca, inclusive com os atributos presentes nas sub-entidades. Por causa deste comportamento, todos os atributos devem ser mapeados no <em>descriptor</em> para serem localizados pelo <code>restful.query</code>, porém existem situações na qual um atributo é do tipo <code>Object</code> ou <code>Array</code> e seus sub-atributos são dinâmicos e impossíveis de serem mapeados. Neste caso, no objeto <em>sync</em> deste atributo deve ser habilitado a opção <code>dynamicData</code> igual a <code>true</code>. Com esta opção habilitada, o método <code>restful.query</code> <strong>não</strong> irá procurar sub-atributos na entidade relacionada pelo atributo dinâmico.</p>
<h4>Observação</h4>
<p>O método <code>restful.query</code> irá internamente chamar o método de busca do Mongoose (<code>Entidade.model.find</code>), portanto a sintaxe presente no objeto de busca do Mongoose é preservada pelo método <code>restful.query</code>, com a diferença de que através do método <code>restful.query</code>, os atributos das entidades relacionadas são enxergadas pelo método de busca, como se eles já estivessem dentro do documento principal.</p>
<p>Para mais informações sobre o método de busca do mongose <a href="https://mongoosejs.com/docs/queries.html">Acesse</a>.</p>
<h4>Atenção!</h4>
<p>Ao realizar uma pesquisa no método <code>restful.query</code>, os atributos com a opção <em>jsonIgnore</em> igual a <code>true</code> <strong>não</strong> serão ignorados. Para que estes atributos sejam ignorados é necessário que o método de preenchimento (explicado logo a seguir) seja chamado.</p>
<h3>Método de Preenchimento</h3>
<p>Caso você deseja preencher os atributos com relacionamentos, basta chamar o método <code>Entidade.fill(&lt;dados&gt;, restful, &lt;opções&gt;)</code>.</p>
<p>Por exemplo, vamos imaginar que você deseje que uma <em>Pessoa</em> tenha o atributo <em>nome</em> ignorado no json e que o atributo <em>casas</em> seja preenchido <strong>independente</strong> do valor contido no <em>sync</em> da modelagem, mas que isto tenha efeito em apenas uma rota especifica. Para isto bastaria fazer a seguinte chamada de código:</p>
<pre class="prettyprint source lang-js"><code>pessoas = await Pessoa.fill(pessoas, restful, {
    sync: {
        nome: { jsonIgnore: true },
        casas: { fill: true }
    }
})
</code></pre>
<p>O primeiro argumento do método <code>fill</code> é uma pessoa ou uma lista de pessoas que terão seus atributos expandidos. O segundo argumento é a instância do Alpha Restful. O último argumento é um objeto opcional contendo opções para o preenchimento.</p>
<p>Neste exemplo, apenas para esta chamada, você está sobrescrevendo o comportamento padrão do <em>sync</em>. Dentre as opções do ultimo argumento, você pode passar a opção <em>syncs</em>, opção esta que é um objeto na qual a chave do objeto é o nome da entidade e o valor é o <em>sync</em> da entidade que substituirá o <em>sync</em> padrão definido na modelagem. Como exemplo disto nós temos:</p>
<pre class="prettyprint source lang-js"><code>pessoas = await Pessoa.fill(pessoas, restful, {
    sync: {
        nome: { jsonIgnore: true },
        casas: { fill: true }
    },
    syncs: {
        Casa: {
            pessoas: { jsonIgnore: true }
        }
    }
})
</code></pre>
<p>Neste exemplo, <strong>independente</strong> do que foi definido na modelagem, apenas para esta chamada, as pessoas terão seu <em>nome</em> removidos do json, o atributo <em>casas</em> será preenchido, mas o atributo <em>pessoas</em> dentro da entidade <em>Casa</em> não será incluído dentro do atributo <em>casas</em> em <em>Pessoa</em>.</p>
<p>As opção passadas no objeto do último argumento são:</p>
<table>
<thead>
<tr>
<th>Opção</th>
<th style="text-align:center">Valor Padrão</th>
<th>Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td>sync</td>
<td style="text-align:center"><code>null</code></td>
<td>Objeto <em>sync</em> a ser usado ao invés do <em>sync</em> definido na modelagem. Se for <code>null</code> usa-se o sync da modelagem</td>
</tr>
<tr>
<td>syncs</td>
<td style="text-align:center"><code>{}</code></td>
<td>Objeto cuja a chave é o nome da entidade e o valor é o <em>sync</em> a ser usado ao invés do <em>sync</em> definido na modelagem de tal entidade. A entidade que não estiver dentro desta opção terá o <em>sync</em> definido em sua modelagem usado.</td>
</tr>
<tr>
<td>ignoreFillProperties</td>
<td style="text-align:center"><code>[]</code></td>
<td>Lista de propriedade que não serão preenchidas em qualquer nível.</td>
</tr>
<tr>
<td>jsonIgnoreProperties</td>
<td style="text-align:center"><code>[]</code></td>
<td>Lista de propriedade que não serão incluídas em qualquer nível.</td>
</tr>
</tbody>
</table>
<h4>Atenção!</h4>
<p>A opção <em>sync</em> do último argumento do método <code>Entidade.fill</code> <strong>apenas</strong> é aplicada ao primeiro nível, ou seja, no exemplo apresentado, se houver alguma sub-entidade que se relaciona com <em>Pessoa</em>, o <em>sync</em> de Pessoa utilizado será o objeto <em>sync</em> definido na modelagem da entidade.</p>
<p>Por causa disso, no exemplo apresentado, o atributo <em>pessoas</em> em <em>Casa</em>, se não estivesse sendo ignorado, utilizaria o objeto <em>sync</em> definido na modelagem da entidade. Para sobrescrever o <em>sync</em> em todas as chamadas e sub-chamadas de todas as sub-entidades de sub-entidades, seria necessário sobrescrever também na opção <em>syncs</em>:</p>
<pre class="prettyprint source lang-js"><code>pessoas = await Pessoa.fill(pessoas, restful, {
    sync: {
        nome: { jsonIgnore: true },
        casas: { fill: true }
    },
    syncs: {
        Casa: {
            pessoas: { jsonIgnore: true }
        },
        Pessoa: {
            nome: { jsonIgnore: true },
            casas: { fill: true }
        }
    }
})
</code></pre>
<h4>Observação</h4>
<p>Por padrão, ao preencher um atributo com a entidade relacionada, todos os valores deste atributo serão preenchidos e estarão dentro do json, mas pode-se ordenar e paginar os resultandos dentro do preenchimento, utilizando as opções <em>limit</em> (quantidade máxima de elementos), <em>skip</em> (quantidade de elementos a serem pulados) e <em>sort</em> (atributo a ser ordenado de maneira crescente ou decrescente (com o hífen no início)).</p>
<p>A opção <em>sort</em> irá ordenar os elementos de dentro do atributo pelo atributo passado nesta opção. Por padrão, apenas atributos armazenados dentro do documento principal poderão ser utilizados pela ordenação. Caso seja necessário ordenar por algum atributo presente na entidade relacionada, é necessário habilitar como <code>true</code> a opção <em>ignoreSubAttr</em>, que irá excluir do json os atributos de relacionamento presentes dentro do documento principal.</p>
<p>Caso a opção <em>ignoreSubAttr</em> seja <code>true</code>, pode-se utilizar a opção <code>find</code> dentro das opções de preenchimento. A opção <em>find</em> permite que seja definido uma especificação de pesquisa, para que apenas as subentidades que se encaixar nestas condições sejam incluídas dentro do json. O valor de <em>find</em> pode ser um objeto literal de busca (objeto a ser utilizado no primeiro argumento do método <code>restful.query</code>), assim como pode ser também uma função que retorna este objeto literal. Para este último caso, o primeiro argumento da função é a instância da entidade que terá seus atributos preenchidos e o segundo argumento da função é um array com todos os valores presentes no documento principal dentro do atributo a ser preenchido.</p>
<p>Também é possível selecionar quais atributos diretos (primeiro nível) estarão contidos dentro do json com a opção <em>select</em>, que pode ser um array com todos os atributos a serem adicionados no json, mas pode ser também uma string, separando os atributos a serem selecionados com espaço.</p>
<h4>Forma Alternativa Para Integrar Preenchimento em Rotas Personalizadas</h4>
<p>O método de preenchimento <code>Entidade.fill</code> pode ser chamado dentro de uma rota personalizada para preencher os atributos com os valores contidos nas entidades relacionadas por eles. Esse método pode ser chamado explicitamente, mas também pode ser chamado de maneira alternativa como uma opção ao método <code>restful.execAsync</code>:</p>
<pre class="prettyprint source lang-js"><code>app.get('/rota-personalizada',
    restful.execAsync(async function (req, res, next) {
        // ...
        // Código da rota personalizada
        // ...

        res._content_ = casas
        next()

    }, Casa.afterGetFill(restful), 200)
)
</code></pre>
<h4>Sync Dinâmico</h4>
<p>Especificamente para a função de preenchimento, pode ser definido um objeto <em>sync</em> dinâmico! Para fazer isto, basta ao invés de passar um objeto, passar uma função, que recebe a entidade na qual se deseja preencher como argumento e retorna o <em>sync</em> a ser utilizado. Isto se torna muito poderoso para os relacionamentos virtuais que serão vistos posteriormente!</p>
<p>Como exemplo disto, imaginemos que somente as pessoas que não tiverem seu <em>nome</em> iniciados com &quot;Emanuel&quot; devem ter seus nomes ignorados no json de resposta. Para fazer isto basta digitar o seguinte código:</p>
<pre class="prettyprint source lang-js"><code>pessoas = await Pessoa.fill(pessoas, restful, {
    sync: pessoa => ({
        nome: { jsonIgnore: !pessoa.nome.startsWith('Emanuel') },
        casas: { fill: true }
    }),
    syncs: {
        Casa: {
            pessoas: { jsonIgnore: true }
        }
    }
})
</code></pre>
<h3>Opções de Remoção de Entidades</h3>
<p>Caso você deseje excluir uma entidade manualmente via linha de código e ainda manter o comportamento definido nos objetos <em>sync</em> para as opções <em>required</em>, <em>deleteCascade</em> e garantir que não existirá ids em relacionamentos apontando para entidades que já não existem mais, basta chamar o método <code>restful.deleteSync(&lt;id&gt;, &lt;nome da entidade&gt;, &lt;syncronized&gt;)</code>.</p>
<p>Como exemplo, o código que garantirá este comportamento na remoção de uma pessoa seria:</p>
<pre class="prettyprint source lang-js"><code>await restful.deleteSync(pessoa._id, 'Pessoa', Pessoa.syncronized)
</code></pre>
<p>O primeiro argumento é o id da pessoa a ser removida. O segundo argumento é uma String contendo o nome da entidade e o terceiro argumento é um objeto gerado automaticamente pelo Alpha Restful, contendo todos os relacionamentos que outras entidades possuem com <em>Pessoa</em>.</p>
<p>Este método <strong>NÃO</strong> irá remover a pessoa. Este método irá manter o comportamento padrão que o Alpha Restful aplica em uma entidade <strong>antes</strong> dela ser removida.</p>
<p>Após a chamada deste método, pode-se remover a entidade usando as ferramentas do Mongoose ou usando as ferramentas disponibilizadas pelo MongoDB.</p>
<p>Como exemplo de um método disponibilizado para remoção de entidades no Mongoose temos:</p>
<pre class="prettyprint source lang-js"><code>await pessoa.remove()
</code></pre>
<h3>Manipulação da Entidade Pelo Moongose e pelo MongoDB</h3>
<p>Caso você dejese salvar, buscar, editar ou remover uma entidade, pode-se utilizar os métodos disponíveis pelo Mongoose ou pelo MongoDB. O <em>schema</em> da entidade descrita pela documentação do Mongoose pode ser obtido através da opção <code>Entidade.schema</code>. O <em>model</em> da entidade descrita pela documentação do Moongose pode ser obtido através da opção <code>Entidade.model</code>. Caso você busque uma entidade pelo método <code>restful.query</code> e deseje ter acesso aos métodos do objeto disponibilizados pelo Mongoose, basta desabilitar a opçao <code>isCopyEntity</code>, assim como é explicado na seção <strong>Método de Busca</strong> deste documento.</p>
<p>Para mais informações sobre os métodos disponibilizados pelo Mongoose para manipulação de entidades acesse a documentação pelo link <a href="https:%5C/%5C/mongoosejs.com/docs/guides.html">https://mongoosejs.com/docs/guides.html</a>.</p>
<h3>Relacionamento Virtual</h3>
<p>Um relacionamento virtual é um relacionamento que existe entre uma entidade com outra entidade por intermédio de uma definição de pesquisa estática.</p>
<p>Digamos que toda vez que buscarmos uma pessoa, gostaríamos de obter dentro da pessoa um atributo contendo a quantidade de casas registradas no sistema. Para isto, podemos fazer um relacionamento virtual.</p>
<pre class="prettyprint source lang-js"><code>const Pessoa = new Entity({
    name: 'Pessoa',
    resource: '/pessoas',
    descriptor: {
        name: String,
        idade: Number
    },
    sync: {
        casas: {
            name: 'Casa',
            syncronized: ['pessoas'],
            fill: true,
            ignoreFillProperties: ['pessoas']
        },

        /*
        Definindo atributo que se relaciona com
        Casa atraves da especificação de uma
        pesquisa
        */
        quantidadeCasas: {
            name: 'Casa',
            virtual: true,
            find: {},
            selectCount: true
        }
    },
    methods: ['get', 'post', 'put', 'delete', 'patch']
})
</code></pre>
<p>Neste exemplo, toda vez que uma pessoa for buscada, o atributo <em>quantidadeCasas</em> será preenchido com a quantidade de casas registrado dentro do sistema. Se a opção <em>find</em> for um objeto vazio ou se não for definido, será buscado todos os elementos registrados na entidade relacionada.</p>
<p>A opção <em>find</em> contém um objeto de pesquisa que será utilizada no primeiro argumento da função <code>restful.query</code>. Além desta opção, estão disponíveis as mesmas opções presentes no objeto do último argumento da função <code>restful.query</code>.</p>
<h4>Relacionamento Virtual Dinâmico</h4>
<p>Digamos que desejamos criar uma entidade chamada de <em>Familia</em>, que contém um atributo chamado de <em>sobrenome</em>.</p>
<pre class="prettyprint source lang-js"><code>const Familia = new Entity({
    name: 'familia',
    resource: 'familias',
    descriptor: {
        sobrenome: String
    },
    methods: ['get', 'post', 'put', 'delete', 'patch']
})

restful.add(Familia)
</code></pre>
<p>Digamos ainda que ao fazer uma pesquisa por esta entidade, desejamos que seja retornado uma lista de todas as pessoas na qual seu nome termine com este sobrenome.</p>
<p>Para fazermos isto podemos utilizar o relacionamento virtual dinâmico, ou seja, haverá um relacionamento lógico, na qual uma entidade estará relacionada com outras entidades por intermédio de uma especificação de busca.</p>
<p>Atualmente, o relacionamento virtual dinâmico <strong>não</strong> está disponível na modelagem da entidade. Porém ele está disponível na chamada do método de preenchimento. Desta forma, podemos criar uma rota personalizada que chama o método de preenchimento e define nesta chamada o relacionamento virtual dinâmico:</p>
<pre class="prettyprint source lang-js"><code>familias = await Familia.fill(familias, restful, {
    sync: familia => ({
        pessoas: {
            name: 'Pessoa',
            virtual: true,
            find: {
                'nome': new RegExp(`${familia.sobrenome}$`)
            }
        }
    })
})
</code></pre>
<p>O Código anterior exemplifica o uso do relacionamento virtual dinâmico. O método <code>Familia.fill</code> irá preencher o atributo <em>pessoas</em> com a entidade relacionada <em>Pessoa</em>. Porém, apenas as pessoas na qual o nome termina com o sobrenome da família em questão, serão usados para preencher o atributo <em>pessoas</em>. Para realizar a verificação de se o nome da pessoa termina com o sobrenome da família, utilizou-se uma expressão regular.</p>
<p>Ao final deste código, cada família terá uma lista com todas as pessoas na qual o seu nome termina com o sobrenome da família em questão. Este código, ao ser colocado em uma rota personalizada, ou em uma projeção (explicada mais a frente) ou em um handler (explicado mais a frente), garantirá que as pessoas sejam separas por famílias, baseada em uma especificação lógica de busca, sem que haja a necessidade (a não ser por questões de performance) de armazenar estes dados no banco de dados.</p>
<h3>Projeção</h3>
<p>Digamos que em determinadas situações, uma pesquisa qualquer deva ser retornada de uma maneira diferente, seja removendo atributos, seja adicionando outros atributos, seja modificando completamente o resultado da pesquisa. Isto pode ser feito através do uso de projeções.</p>
<p>As projeções podem ser definidas como array, objeto ou função.</p>
<h4>Projeção Definida como Array</h4>
<p>Digamos que em determinadas situações, independente da rota utilizada, uma pessoa somente deverá retornar os atributos <em>nome</em> e <em>idade</em>. Neste caso podemos criar uma projeção, por exemplo com o nome de <em>projecao-base</em>.</p>
<pre class="prettyprint source lang-js"><code>const Pessoa = new Entity({
    //...
    projections: {
        'projecao-base': ['nome', 'idade']
    }
})
</code></pre>
<p>Para chamar esta projeção em uma requisição http basta adicionar o atributo <code>projection=projecao-base</code> em alguma rota já existente de busca.</p>
<p>Por exemplo, se quisermos chamar esta projeção para a rota de busca de todas as pessoas, nós podemos fazer a seguinte requisição:</p>
<pre class="prettyprint source lang-http"><code>/pessoas?projection=projecao-base
</code></pre>
<h4>Projeção Definida como Objeto</h4>
<p>Ainda continuando nossos exemplos de projeção, se quisermos que nossa projeção <em>projecao-base</em> retorne APENAS pessoas contendo 1 (um) atributo, sendo este atributo uma concatenação do nome com a idade da pessoa, basta fazer o seguinte:</p>
<pre class="prettyprint source lang-js"><code>const Pessoa = new Entity({
    //...
    projections: {
        'projecao-base': {
            nomeComIdade: pessoa => `${pessoa.nome} ${pessoa.idade}`
        }
    }
})
</code></pre>
<h4>Projeção Definida Como Função</h4>
<p>E se quisermos que nossa projeção <em>projecao-base</em> retorne, além do atributo <em>nomeComIdade</em>, os outros atributos também? Neste caso basta que nossa projeção seja uma função (sincrona ou assincrona) que adiciona o atributo <em>nomeComIdade</em>:</p>
<pre class="prettyprint source lang-js"><code>const Pessoa = new Entity({
    //...
    projections: {
        'projecao-base': async function (pessoa, resolve, reject) {
            try {
              pessoa.nomeComIdade=`${pessoa.nome} ${pessoa.idade}`
              resolve(pessoa)
            } catch (err) {
              reject(err)
            }
        }
    }
})
</code></pre>
<p>Independente de nossa projeção ser assincrona ou sincrona, o método <code>resolve</code> deve ser chamado, sendo o argumento o objeto que será retornado pela rota. Em caso de erro, pode-se chamar o método <code>reject</code>, passando como argumento o objeto do erro.</p>
<h4>Projeção Padrão</h4>
<p>E se quisermos que nossa projeção <em>projecao-base</em> seja executada automaticamente sem precisarmos passar <code>projection=projecao-base</code> em nossas requisições http? Para isto basta definir na entidade a opção <em>projectionDefault</em>:</p>
<pre class="prettyprint source lang-js"><code>const Pessoa = new Entity({
    //...
    projections: {
        'projecao-base': async function (pessoa, resolve) {
            pessoa.nomeComIdade=`${pessoa.nome} ${pessoa.idade}`
            resolve(pessoa)
        }
    },
    projectionDefault: 'projecao-base'
})
</code></pre>
<h4>Integrando as Projeções com Nossas Rotas Personalizadas</h4>
<p>E se quisermos que nossas rotas personalizadas também usem nossas projeções? Neste caso basta adicionar dois novos argumentos no utilitário <code>restful.execAsync</code> e adicionar aquilo que seria enviado no atributo <code>res._content_</code>:</p>
<pre class="prettyprint source lang-js"><code>app.get('/rota-personalizada',
    restful.execAsync(async function (req, res, next) {
        // ...
        // Código da rota personalizada
        // ...

        res._content_ = pessoas
        next()

    }, Pessoa.afterGetProjections(restful), 200)
)
</code></pre>
<h5>Observação</h5>
<p>Para que o código anterior funcione, é necessário que no código de sua rota personalizada não seja enviado nenhum dado como resposta. Aquilo que seria enviado pela rota como resposta deve ser adicionado na variavel <code>res._content_</code>, que o Alpha Restful se encarregará de enviar seu conteúdo.</p>
<p>No último argumento do <code>restful.execAsync</code> encontra-se o <em>status code</em> de resposta do http. Caso você deseje, ao invés de colocar no ultimo argumento o <em>status code</em>, você pode passar outra função que se encarregará de enviar o conteúdo presente no <code>res._content_</code>.</p>
<h4>Aplicando Projeções em um Objeto Qualquer</h4>
<p>Se você deseja aplicar uma projeção de uma entidade em um objeto qualquer, basta você chamar o método <code>&lt;Entidade&gt;.applyProjections(&lt;content&gt;, &lt;projectionName&gt;, restful)</code>. Isto é muito útil para aplicar uma projeção em um atributo estando dentro da implementação de outra projeção.</p>
<p>Como exemplo disto, vamos criar uma projeção da entidade <em>Casa</em>, na qual tal projeção simplesmente aplica a projeção <em>projecao-base</em> de <em>Pessoa</em> no atributo <em>pessoas</em>:</p>
<pre class="prettyprint source lang-js"><code>const Casa = new Entity({
    // ...
    projections: {
        'projecao-casa': async function (casa, resolve) {

            /*
            Dentro de uma projeção é altamente recomendável
            obter a entidade desejada por meio do atributo
            restful.entities
            */
            const Pessoa = restful.entities.Pessoa

            casa.pessoas = await Pessoa.applyProjections(
                casa.pessoas, 'projecao-base', restful
            )

            resolve(casa)
        }
    }
})
</code></pre>
<h3>Handlers</h3>
<p>Por fim, vamos falar sobre os handlers! Um handler basicamente é uma função que será executada em algum momento específico. Por padrão os handlers são executados antes ou depois de cada rota CRUD http padrão gerada pelo Alpha Restful. Mas você pode integrar os handlers as suas rotas personalizadas.</p>
<p>Aqui está a lista de handlers disponíveis:</p>
<table>
<thead>
<tr>
<th>Handler</th>
<th>Descrição</th>
</tr>
</thead>
<tbody>
<tr>
<td>beforeQuery (req, res, next)</td>
<td>Executado antes de aplicar uma rota <em>get</em></td>
</tr>
<tr>
<td>afterQuery (entity, req, res, next)</td>
<td>Executado após a aplicação de uma rota <em>get</em></td>
</tr>
<tr>
<td>beforeCreate (entity, req, res, next)</td>
<td>Executado antes da aplicação de uma rota <em>post</em></td>
</tr>
<tr>
<td>afterCreate (entity, req, res, next)</td>
<td>Executado após a aplicação de uma rota <em>post</em></td>
</tr>
<tr>
<td>beforeRemove (entity, req, res, next)</td>
<td>Executado antes da aplicação de uma rota <em>delete</em></td>
</tr>
<tr>
<td>afterRemove (entity, req, res, next)</td>
<td>Executado após a aplicação de uma rota <em>delete</em></td>
</tr>
<tr>
<td>beforeEdit (entity, req, res, next)</td>
<td>Executado antes da aplicação de uma rota <em>put</em> ou <em>patch</em></td>
</tr>
<tr>
<td>afterEdit (entity, req, res, next)</td>
<td>Executado após a aplicação de uma rota <em>put</em> ou <em>patch</em></td>
</tr>
</tbody>
</table>
<p>Apenas o handler <code>beforeCreate</code> não recebe o conteúdo da entidade (ou entidades) como primeiro argumento. Nos demais handlers, o primeiro argumento é o conteúdo que está sendo manipulado. Este conteúdo também pode ser acessado pelo <code>res._content_</code>.</p>
<h4>Atenção</h4>
<p>Independente do handler ser uma função assincrona ou sincrona, o método <code>next()</code> deverá ser chamado ao final da execução do handler. Caso algum erro ocorra, pode-se chamar o método <code>next</code> passando como argumento o bjeto do erro.</p>
<h4>Implementando um handler</h4>
<p>Para implementar um handler basta adicionar um método na entidade com o nome do handler desejado. Como exemplo vamos implementar o handler <code>afterQuery</code> que apenas irá printar a lista de pessoas antes de retornar na requisição.</p>
<pre class="prettyprint source lang-js"><code>Pessoa.afterQuery = async function (pessoas, req, res, next) {
    console.log(pessoas)
    next()
}
</code></pre>
<p>Caso ocorra algum erro dentro do handler, basta passar o objeto do erro na função <code>next</code>.</p>
<h4>Integrando os Handlers a suas Rotas Personalizadas</h4>
<p>No utilitário <code>restful.execAsync</code>, você deverá chamar antes ou depois de sua(s) rota(s) personalizada(s) os handlers desejados, sempre lembrando que o Alpha Restful irá colocar como primeiro argumento de todos os handlers (com exceção do handler <code>beforeCreate</code>) o conteúdo da variável <code>res._content_</code>.</p>
<p>Para obter um handler, basta chamar a função <code>Entidade.getRouteHandler(&lt;nome-do-handler&gt;)</code>. O argumento da função <code>getRouteHandler</code> é o nome do handler.</p>
<p>Para exemplificar esta integração, definiremos uma rota personalizada que utilizará os handlers <code>beforeEdit</code> e <code>afterEdit</code>.</p>
<pre class="prettyprint source lang-js"><code>app.put('/edit-pessoa',
    restful.execAsync(
        async function (req, res, next) {
            // ... faz alguma coisa
            // ... busca a pessoa
            // ... faz outra coisa

            res._content_ = pessoa
            next()
        },
        Pessoa.getRouteHandler('beforeEdit'),
        async function (req, res, next) {
            // ... faz alguma coisa
            // ... edita a pessoa
            // ... faz outra coisa
            next()
        },
        Pessoa.getRouteHandler('afterEdit'),
        200
    )
)
</code></pre>
<p>Neste exemplo nós chamados o handler <code>beforeEdit</code> e o handler <code>afterEdit</code>, mas poderíamos chamar somente um deles ou nenhum deles. O último argumento é o <em>status code</em> http que será retornado caso tudo dê certo.</p>
<p>Por fim, se quisessemos integrar nossa rota personalizada ao <code>beforeEdit</code>, ao <code>afterEdit</code> e as nossas projeções explicadas anteriormente, poderíamos fazer o seguinte:</p>
<pre class="prettyprint source lang-js"><code>app.put('/edit-pessoa',
    restful.execAsync(
        async function (req, res, next) {
            // ... faz alguma coisa
            // ... busca a pessoa
            // ... faz outra coisa

            res._content_ = pessoa
            next()
        },
        Pessoa.getRouteHandler('beforeEdit'),
        async function (req, res, next) {
            // ... faz alguma coisa
            // ... edita a pessoa
            // ... faz outra coisa
            next()
        },
        Pessoa.afterGetProjections(restful),
        Pessoa.getRouteHandler('afterEdit'),
        200
    )
)
</code></pre>
<p>Veja que aqui optamos por aplicar as projeções antes de nosso handler <code>afterEdit</code>, mas tranquilamente poderíamos alterar a ordem na qual essa chamadas são realizadas.</p>
<h2>Algumas Informações Importantes</h2>
<p>O guia aqui presente engloga a grande maioria das funcionalidades implementadas, porém ainda existem alguns detalhes não especificados aqui. Em breve atualizarei este guia colocando nele mais informações.</p>
<p>Sinta-se a vontade de testar as funcionalidades aqui apresentadas e em caso de algum erro você poderá relatar aqui nas Issues que eu tentarei resolver o mais rápido possível.</p>
<p>Este software ainda <strong>não</strong> está 100% pronto. Existem alguns detalhes importantes a serem tratados e testes mais severos a serem realizados.</p>
<p>Sinta-se livre para sugerir qualquer mudança no framework ou para realizar qualquer sugestão de atualização de seu código fonte.</p>
        </article>
    
</section>



</div>

<footer>
    <img class="logo" src="img/toast-ui.png" style="">
    <div class="footer-text">Alpha Restful develop by emanuelmoraes-dev</div>
</footer>
<script>prettyPrint();</script>
<script src="scripts/jquery.min.js"></script>
<script src="scripts/tui-doc.js"></script>
<script src="scripts/linenumber.js"></script>

    <script>
        showLnbExamples();
    </script>

</body>
</html>